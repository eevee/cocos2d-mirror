Actions, Transformations and Effects
====================================

.. contents::
	:local:
	
Actions
-------

Actions are like orders given to any `CocosNode` object.
These actions usually modify some the object's attributes like `position`,
`rotation`, `scale`, etc. If these attributes are modified during a period of time,
they are `IntervalAction` actions, otherwise they are `InstantAction` actions.

For example, the `MoveBy` actions modifies the `position` attribute during a period
of time, hence, it is an `IntervalAction`.

Example::

	# Move a sprite 50 pixels to the right, and 100 pixel to the top in 2 seconds.
	sprite.do( MoveBy( (50,100), duration=2 ) )
	
`InvertalAction` has some interesting properties:

	- The can be accelerated using the time-altered actions
		- `Accelerate`
		- `AccelDeccel`
		- `Speed`
	- They can be executed backwards in time with the `ReverseTime` action.
	  The starting point will be ending point, and vice-versa.
	- All the relative actions (the ones ending in 'By') have a `Reverse` action
	  that executes the action in the opposite direction.



Basic actions
-------------

Basic actions are the ones that modifies basic attributes like:

 - position
	- `MoveBy`
	- `MoveTo`
	- `JumpBy`
	- `JumpTo`
	- `Bezier`
	- `Place`

 - scale
 	- `ScaleBy`
 	- `ScaleTo`

 - rotation
 	- `RotateBy`
 	- `RotateTo`

 - visible
 	- `Show`
 	- `Hide`
 	- `Blink`
 	- `ToggleVisibility`

 - opacity
 	- `FadeIn`
 	- `FadeOut`
 	- `FadeTo`
 	

Example::

	XXX: finish this part
  

Effects
-------

There are 2 kind of grids: ``tiled`` grids and ``non-tiled`` grids. The difference is that
the ``tiled`` grid is composed of individual tiles while the ``non-tiled`` grid is
composed of vertex.

.. image:: tiled_and_nontiled_grid.png

The grids has 2 dimensions: ``rows`` and ``columns``, but each vertex of the grid has
3 dimension: ``x``, ``y`` and ``z``. So you can create 2d or 3d effects by transforming
a ``tiled-grid-3D`` or a ``grid-3D`` grid.


How they work
^^^^^^^^^^^^^

Each frame the screen is rendered into a texture. This texture is transformed into a ``vertex array``
and this ``vertex array`` (the grid!) is transformed by the grid effects.
Finally the ``vertex array`` is rendered into the screen.

For more information about the internals refer to:
 - `TiledGrid3D` and `TiledGrid3DAction` for ``tiled`` grids
 - `Grid3D` and `Grid3DAction` for ``non-tiled`` grids


Index of grid effects
^^^^^^^^^^^^^^^^^^^^^

 - TiledGrid3D actions
	- `ShatteredTiles3D`
	- `ShakyTiles3D`
 	- `JumpTiles3D`
 	- `WavesTiles3D`
	- `ShuffleTiles`
 	- `TurnOffTiles`
 	- `FadeOutTiles`

 - Grid3D actions
 	- `Lens3D`
 	- `FlipX3D`
 	- `FlipY3D`
 	- `Waves3D`
 	- `Shaky3D`
	- `Liquid`
 	- `Waves`
	- `Twirl`
 	- `QuadMoveBy`
 	- `Flip`
 	- `FlipX`
 	- `FlipY`
 	- `SkewHorizontal`
 	- `SkewVertical`
 	- `MoveCornerUp`
 	- `MoveCornerDown`
 	- `CornerSwap`


Example::
	
	scene.do( Twirl( grid=(16,12), duration=4) )
	layer1.do( Lens3D( grid=(32,24), duration=5 )
	layer2.do( Waves( grid=(16,12), duration=4) + Liquid( grid=(16,12), duration=5 ) )
	

Composition
-----------

 - `Sequence`
 - `Spawn`
 - `Repeat`
 
Example::

	XXX: finish this part

	
Modifiers
---------

 - Time modifiers
	- `Accelerate`
	- `AccelDeccel`
	- `Speed`
	- `Reverse`
	- `ReverseTime`

 - Amplitude modifiers
	- `AccelAmplitude`
	- `AccelDeccelAmplitude`
   
Exmaple::
	
	XXX: finish this part
	

Special Actions
---------------

  - `Delay`
  - `RandomDelay`
  - `CallFunc`
  - `CallFuncS`
  - `DoAction`
  - `StopGrid`
  - `ReuseGrid`
  - `OrbitCamera`
 
 Example::
 
 	XXX: finish this part
	
Creating your own actions
-------------------------

Creating your own actions is pretty easy. You should familiarize yourself with this concepts, 
because actions are very powerful and can be combined with another actions to create more actions. 

For example, there is the Blink action. It is implemented by subclassing `IntervalAction`, 
but you could actually do something like::

	def Blink(times, duration): 
		return (
			Hide() + Delay(duration/(times*2)) + 
			Show() + Delay(duration/(times*2)) 
		) * times
	
Basic Internals
^^^^^^^^^^^^^^^

All actions work on a `target`. Its their callers responsability to set 
the target to the correct element. This allows the user to instantiate an action and then apply the same
action to various different elements. All cocosnodes can be a target for an action.

You will not know who the target is when `__init__` or `init` is called, but you will when `start` is called. If 
you are making an action that takes more actions as parameters, it is your responsability to:
   - set the target
   - call the start method
   - call the stop method
   
You can also override the `__reversed__` method. In this method you have to construct and return an action 
that would be the reversed version of the action you are doing. For example, 
in `Show()` we return `Hide()` as its reverse::
	class Show( InstantAction ):
	    "<snip>"
	    def __reversed__(self):
		return Hide()

		
Instant Actions
^^^^^^^^^^^^^^^

Instant actions are actions that will take no time to execute. For example, `Hide()` 
sets the target visibility to False. 

It is very easy to create an action using the CallFuncS action as a decorator::
	@CallFuncS
        def make_visible( sp ):
            sp.do( Show() )
        self.sprite.do( make_visible )
	
please note that make_visible will not be a regular function that you can call, 
it will be an action. So you can compose it like any other action.

If you want to subclass InstantAction, you will have to override:
  - the `init` method to take the parameters you desire
  - the `start` method to do the action
  
Thats it.

For example, this is a minimal implementation of SetOpacity::

	class SetOpacity( InstantAction ):
	    def init(self, opacity):
	        self.opacity = opacity
	    def start(self):
		self.target.opacity = self.opacity
		
Interval Actions
^^^^^^^^^^^^^^^^

Interval actions is where the fun is. With this actions you can specify
transformations that take a finite time. For example, `MoveBy(how_much, duration)`.

The protocol for `IntervalAction` subclasses is the following:
   - `init` method will be called. here you have to set your `duration` property.
   - a copy of the instance will be made (you dont have to worry about this)
   - `start` method will be called (`self.target` will be set)
   - `update(t)` will most likely be called many time with t in [0,1) and t will monotonically rise.
   - `update(1)` will be called.
   - `stop()` will be called.
   
So its in update that you do your magic. For example, if you want to fade something out, 
you can write something like::
	class FadeOut( IntervalAction ):
	    def init( self, duration ):
		self.duration = duration
	
	    def update( self, t ):
		self.target.opacity = 255 * (1-t)
	
	    def __reversed__(self):
		return FadeIn( self.duration )

The trick is that whoever is running your action will interpolate the values of t so that you 
get called with `t==1` when your duration is up. This does not mean that `duration` seconds 
have elapsed, but it usually does. If someone wants to make your action go twice as fast, they can feed you 
updates at a different rate and you should not care.

Also, this allows us to change the interpolation method. We usually use linear interpolation, 
but `AccelDeccel`, for example, uses a sigmoid funcion so that is goes slower at the ends.
