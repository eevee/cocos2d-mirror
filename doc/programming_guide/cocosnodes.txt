CocosNodes
==========

.. contents::
    :local:

CocosNode Functionality
-----------------------

The fact that all objects depicting the scene are CocosNodes subclasses means that they share a common core of characteristics and functionalities. You know for one and you know for all.

The common core can be broken by functionality in

Parent-child
^^^^^^^^^^^^

    - .add(self, child, z=0, name=None ) \: Adds a child, raises exception Name already exists if duplicated
    - .remove(self, name_or_obj) \: Removes a child given its name or object, raises exception Child not found if not present
    - .kill(self) \: Remove itself from its parent
    - .parent \: property giving the parent node or None
    - .get_ancestor(self, klass) \: Returns the first ancestor that isinstance of klass 
    - .get_children(self) \: Returns a list with the node children, order is back to front (ascending z)
    - .get(self, name) \: Gets a child given its name, raises exception Child not found if not present
    - operator in , as 'in node1 in node2' \: returns True if and only if node1 is child of node 2

Building a scene, object instantiation omitted ::

    # a scene with 2 layers; the background would be seen behind the game layer because of z values
    scene.add( background_layer, z=0 )
    scene.add( game_layer, z=1 )

    # the layer with 1 bloody pacman sprite
    blody_pacman_sprite.position = (100, 100)
    game_layer.add( bloody_pacman_sprite )

    # the bloody pacman has two daggers !!!
    sprite.add( dagger_far_sprite, z=-1 )
    sprite.add( dagger_near_sprite, z=1  )
    # the draw order is dagger_far, bloody_pacman, dagger_near

    # also they are zombie alien cowboys in the game,
    # so we add a bunch of them to the game_layer
    ...
 

A dagger has touched a zombie alien cowboy so it wants to spawn a nasty blotch of green blood.
We could add the blotch_sprite to the zac_sprite, an then the blotch will follow the zombie::

    zac_zprite.add(blotch_sprite, z = 1)

or we could add to the game_layer, and the blotch will not follow the zombie::

    layer = zac_sprite.parent # should be game_layer, because our staggering
    layer.add(blotch_sprite)

If for some ridiculous reason a dagger needs to grab a reference to the game_layer we could use 'get_ancestor'.
Due to to way we staged the scene, we know game_layer is parent of bloody_pacman_sprite which is parent of the dagger. So::

    layer = dagger_near.get_ancestor(Layer)

should produce game_layer.

A zombie is killed, we can retire from the scene with::

    zac_sprite.kill()

or with::

    game_layer.remove(zac_sprite)

or if we named it "T'chkss" when we added to the game_layer, like in::

    game_layer.add(zac_sprite, name = "T'chkss", z=4)

then we can retire it with::

    game_layer.remove("T'chkss")

Note that in current cocos if you add with name then you should remove by name,
else the name will become unusable for new additions.


Spatial Placement
^^^^^^^^^^^^^^^^^

A node position is defined relative to the parent node, most precisely with respect the parent position anchor  

    - .x
    - .y
    - .position property equivalent to (.x, .y)
    - .anchor_y
    - .anchor_y
    - .anchor   (property equivalent to (anchor_x, .anchor_y)
    - .scale
    - .rotation

Example::

    # place the sprite in 320,240
    sprite.position = (320,240)

or by using actions.
Example::

    # move the sprite to 320,240 in 5 seconds
    sprite.do( MoveTo( (320,240, duration=2 ) )
    
Going in or out of the active scene
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    - .on_enter(self) \: called if added to a parent while parent in the active scene or if the entire scene goes active
    - .on_exit(self) \: called if removed from parent while parent in the active scene or if the entire scene

    
Render
^^^^^^

    - .visit(self) : renders itself and its children. Render order is children with z <= 0, itself, children with z > 0
    - .draw(self) : draws itself
    - .transform(self) : helper for draw and visit, handles the openGL coordinate changes needed to render mandated by position, anchor, scale and rotation
    - .camera : instead of the stock position, anchor, scale and rotation uses a custom gluLookAt that also allows z. This is rarely used, usually by special effects in transitions.

    
Time management
^^^^^^^^^^^^^^^

    - .schedule_interval(self, callback, interval, \*args, \*\*kwargs) \: Schedule a function to be called every interval seconds.
    - .schedule(self, callback, \*args, \*\*kwargs) \: Schedule a function to be called every frame.
    - .unschedule(self, callback) : Remove a function from the schedule.
    - .pause_scheduler(self) \: Time will stop passing for this node: scheduled callbacks will not be called, worker actions will not be called
    - .resume_scheduler(self) \: Time will continue/start passing for this node and callbacks will be called, worker actions will be called

    
Automated changes along the time
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    - .do(self, template_action, target=None) \: most of the time it is called with target=None, which result in target being self. The action will perform a potentially gradual change in target. Returns the worker action, which is the object doing the changes. You must save a reference to the worker if you plan to call later to .action_remove
    - .action_remove(self, worker_action) \: the worker action will 
    - .pause(self) \: Suspends the execution of actions.
    - .resume(self) \: Resumes the execution of actions.
    - .stop(self) \: All actions scheduled in this node are removed, stop method will be called for each action.
    - .are_actions_running(self) \: True or False
    

You can modify these attributes to **any** `CocosNode` object.
By example::

    scene.do( ScaleTo(2, duration=2) )

    layer.do( RotateBy(360, duration=3) )

    sprite.do( Blink(5, duration=1 ) )

    label.do( JumpBy( (100,100), 50, 5, duration=3) )



Brief tour of built-in cocosnode objects
----------------------------------------

Scene
^^^^^

The root of the tree depicting the full content of the window.

In the common case, contains all elements visible on the app window.

These properties are not available:

- color
- opacity

TransitionScene
^^^^^^^^^^^^^^^

'TransitionScene',

Base class to implement a gradual change from one screen (scene) to other. Typical examples are fade in and fade out.

Cocos provides a bunch of ready made scene transitions (sample code in test/test_transition_*.py), the more simpler and supported for nearly any hardware / openGL drivers are:

`RotoZoomTransition`, `JumpZoomTransition`, `MoveInLTransition`, `MoveInRTransition`,
`MoveInBTransition`,`MoveInTTransition`, `SlideInLTransition`,`SlideInRTransition`,
`SlideInBTransition`, `SlideInTTransition`, `ShrinkGrowTransition`, `FadeTransition`, `ZoomTransition`

Other transitions available, requiring FBO (Frame Buffer Object) support from openGL which is nearly universal these days are:

`FlipX3DTransition`, `FlipY3DTransition`, `FlipAngular3DTransition`, `ShuffleTransition`, `TurnOffTilesTransition`, `FadeTRTransition`, `FadeBLTransition`, `FadeUpTransition`,
`FadeDownTransition`, `CornerMoveTransition`, `EnvelopeTransition`, `SplitRowsTransition`,
`SplitColsTransition`

Layer
^^^^^

TODO: explain `Layer`

These properties are not available:

- color
- opacity


MultiplexLayer
^^^^^^^^^^^^^^

asdasdasd

ScrollingManager
^^^^^^^^^^^^^^^^

These properties are not available:

- color
- opacity


ScrollableLayer
^^^^^^^^^^^^^^^

These properties are not available:

- color
- opacity


ColorLayer
^^^^^^^^^^

TODO: explain `ColorLayer`


RectMapLayer and HexMapLayer
^^^^^^^^^^^^^^^^^^^^^^^^^^^^



InterpreterLayer
^^^^^^^^^^^^^^^^


Sprite
^^^^^^

Sprites allows to display a image in a rectangular area, which can be rotated,
scaled and moved.
The placement in the scene follows the standard CocosNode rules.
Also, all stock actions will work with sprites.


Animating a sprite
++++++++++++++++++

Animation as in cartoon style animation, that is, replacing the image fast
enough to give the illusion of movement, can be accomplished by:

- using an animated .gif file as source for the image
- passing a pyglet.image.Animation as image, which collects a number of images
- have an array of images and let your code assign to the sprite image member

Performance Considerations
++++++++++++++++++++++++++

Sprites are not suitable for effects that piles a lot of semitransparent images
to render things like smoke or poisoning fog. Use particle systems or custom
CocosNode s managing vertex lists for that.

If your scene has less than 25 sprites, you can add directly to the
scene, like::

    class TLayer(cocos.layer.Layer):
        is_event_handler = True
        def __init__(self):
            cocos.layer.Layer.__init__(self)
            world_width, world_height = director.get_window_size()
            rand_color = [255, 0, 0]
            icolor = 0
            for i in range(qty_balls):
                ball = Ball((world_width*random.random(), world_height*random.random()), color=rand_color)
                rand_color[icolor] = random.randint(50, 255)
                icolor = (icolor + 1)%len(rand_color)
                self.add(ball)
    self.time = 0.0
    self.schedule(self.update)

When you have between 25 and 100 visible sprites, moving at each frame, you
should add one or more BatchNode s at some level in the scene and add the
sprites to them. Even only one batch can give you 4x fps::

    class TLayer(cocos.layer.Layer):
        is_event_handler = True
            def __init__(self):
                cocos.layer.Layer.__init__(self)
                batch = cocos.batch.BatchNode()
                self.add(batch) # we add a batch to the layer ...
                world_width, world_height = director.get_window_size()
                rand_color = [255, 0, 0]
                icolor = 0
                for i in range(100):
                    ball = Ball((world_width*random.random(), world_height*random.random()), color=rand_color)
                    rand_color[icolor] = random.randint(50, 255)
                    icolor = (icolor + 1)%len(rand_color)
                    batch.add(ball) # see ? we add sprites to the batch, not the layer
                self.batch = batch
                self.time = 0.0
                self.schedule(self.update)

With more than 100 visible, moving at each frame sprites, you will need to
optimize further to run at 60 fps in weak hardware like netbooks, old desktops,
cheap new desktops.
You can look at cocos particle systems and the section graphics in pyglet
programing guide for ideas.


ParticleSystems
^^^^^^^^^^^^^^^

Certain effects are best rendered as a big number of translucent, colored images, by example explosions and smoke.
Cocos provides the base class `ParticleSystems` to efficiently render those entities, and some specialized subclasses like `Fireworks`, `Spiral`, `Meteor`, `Sun`, `Fire`, `Galaxy`, `Flower`, `Explosion`, `Smoke`.

The most common method to customize particle systems is to subclass one of the cocos particle systems and modify some of the class members defining its behavior.
If you change the particle texture remember to load it with pyglet.image.load, not pyglet.resource.image
Of course, deeper customization can be achieved with subclassing and code customization.

Label
^^^^^

`Label` s provide the most simple text display.
Font family, font size, position, color, opacity and align can be specified.

`HTMLLabel` s is a slightly more powerful label, it can use mixed styles. Uses HTML syntax for text and styles.

These properties are not available:

- camera


Menu
^^^^

TODO: explain `Menu`

TODO: explain `MultiplexLayer`

These properties are not available:

- color
- opacity


MenuItem
^^^^^^^^

TODO: explain `MenuItem`

TODO: explain `MultipleMenuItem`

TODO: explain `ToggleMenuItem`

TODO: explain `EntryMenuItem`

TODO: explain pre-defined actions: `shake` , `shake_back` ,
`zoom_in` and `zoom_out`

These properties are not available:

- color
- opacity


Creating your own objects
^^^^^^^^^^^^^^^^^^^^^^^^^

TODO: explain how to build custom cocosnode objects,
how to use `transform` , etc.
